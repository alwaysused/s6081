1.每个数组元素一个锁，kalloc获取cpu->idx->锁
2.freerange

==================
1.去掉?bacache.lock
2.buff链表，改成数组，13个。(误会，本身是数组，链表是为了lru)
3.查找改成。。  块数不可能一起，但是可能是散列到同一个。

找块使用。

（test1怎么弄。）
4.bcache保留lock，每个有lock
5.映射怎么解决..
============
1.去除next只是去除bcache里面的，不是buff
2.依然维护一个哈希表，使用链表。
go on,still problem
hash 13, lock ,find exist, 
如果不存在是否释放，

理下。
（小的也需要考虑就崩溃了。。）
1.初始策略很重要，比如要哪几个锁，在这里是hash的锁

2. 加锁与本身，这里可能写hash表那里还有转移，逻辑就复杂了，可以先写不加锁的，与上面并行
或者写伪代码

3.很想把锁及时release。这个时候考虑，另外一个线程来了。
这里的情况是
{
A

B

}
A和B都有用锁，A简单，B复杂，那么释放锁就考虑到本身A和B，和另外一个线程来到了A
或者来到了B,释放有没有问题，能不能想清楚。比如lec就建议 用大锁，以免想不清楚。

4. 这个是个列表锁，比 两个锁要难看出来 死锁的情况。
